### Mon, Jan 2

- API 개발 코드 리뷰 반영함
  - 리뷰에서 배운것들
  - validation error는 log and return 보다 throw 하는게 좋다.
  - DB find, 즉 select 해서 가져올 때, where에 필터를 적용해서 가능하면 필요한 것만 불러오는게 좋다. 즉, 다 불러와놓고 거기서 필터링을 하지 말고, 애초에 where에서 필터를 적용하자.
  - let은 사용을 지양하는게 좋다. mutable하다는것은 예상치 못한 사이드 이펙트를 유발할 수 있고, 어차피 대부분 const로 처리 가능하다. let이 들어간다면 더 간결한 functional 로직으로 대체 가능하거나 또는 애초에 함수 분리가 제대로 안된건지 의심해야 한다.
- 특이한 이슈로 인해 DB 트랜잭션 개념에 대해서 다시 상기하게됨. 그리고 다양한 변수로 인해 트랜잭션이 실패했을 때의 사이드 이펙트를 제대로 점검해볼 필요가 있다는것도 깨닫게 됨
  - 예를 들어, DB 트랜잭션이 실패했는데, 온체인 트랜잭션은 성공한다면? 반대로 온체인 트랜잭션은 실패했는데, DB 트랜잭션은 성공한다면? 이런 케이스들을 항상 염두에 두자.

### Mon, Jan 3

- Secureum RACE-13에서 평균보다 꽤 높은 점수를 얻을 수 있었다. 물론 32인 리더보드에는 들어가지 못했지만 그래도 그 전보다 많은 발전이 있었다.

### Jan 4 ~ 9

- 휴가

### Sun, Jan 8

- typeORM의 Repository에는 count 메소드가 있다. 이를 통해 해당하는 Row의 수를 셀 수 있다. 만약 특정 조건의 데이터의 숫자를 세는것만이 목적이라면 `Repository<T>.count({filter...})` 를 사용하는 함수를 별도로 만드는것이 더 나을 수 있다.
- typesciprt에서 `??` 는 널 병합 연산자(Nullish Coalescing)로 는 왼쪽 피연산자가 null 또는 undefined일 때 오른쪽 피연산자를 반환하고, 그렇지 않으면 왼쪽 피연산자를 반환하는 논리 연산자이다.
  - 예를 들어, 아래와 같은 코드는 해당 id의 유저가 존재하지 않으면 새로 유저를 생성하여 return 하게 된다.
    `return getUser(id) ?? createUser()`
- 기존 코드를 변경하지 않는다고해서 무조건 좋은것이 아니다. 내가 작성한 코드이건 다른 사람이 작성한 코드건 새로운 기능을 추가하거나 리팩토링을 할 때 개선할 수 있으면 개선하는것이 좋다. 반드시 예전 코드베이스에서만 놀아야 하는것은 아니다.
  - 이번 스프린트에서는 이런 실수가 있었다. 기존 코드를 바꾸지 않아야 한다는 강박이 있어서 코드를 비효율적으로 확장성이 낮게 짜는 실수를 했다.
