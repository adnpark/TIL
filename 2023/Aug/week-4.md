# 8월 21일 월요일

- 현재까지 사용된 가스 비용을 계산하는 함수를 만들었다.

  - Promise.all을 사용해서 알케미 API 리퀘스트를 병렬처리를 효율적으로 하는 방법을 배웠다.
  - 알케미에서 블록 읽어올 때는 1000개 단위로 읽는게 가장 안정적이다.

- redis 30분짜리 크래시 코스를 학습했다.

  - 기본적인 redis의 사용법을 익혔다. key 이름을 잘 설정하는게 왜 중요한지, 그리고 ttl과 invalidate가 왜 중요한지 다시 한번 깨달았다.

- seaport 기본적인 얼개를 잡았다.
  - Consideration이 핵심 컨트랙트라는것을 알았다.
  - 근데 죄다 어셈블리라서 이해가 어렵다. 이번 기회에 어셈블리 제대로 익히게 될듯

# 8월 22일 화요일

- 서버리스 아키텍쳐에 대해서 학습했다.
  - 서버리스는 서버가 진짜로 없는게 아니라 모든 서버 인프라를 추상화하는데 의미가 있다.
  - 그리고 그 과정에서 서버리스로 하더라도 현재 코스모 백엔드는 서버리스로 바꾸더라도 스케일링이 의미없다는것을 알게 됐다.
  - 핵심은 api 서버의 스케일링이 아니라, DB의 스케일링이다.
  - DB 성능을 끌어올리는것이 관건이다.
- foundry expectEmit() 치트코드가 이해가 안돼서 좀 더 찾아봤다. 그래도 이해가 잘안된다... 흠...
- seaport 컨트랙트에서 기본적인 order 구조를 파악했다.

# 8월 23일 수요일

- 서버리스에 대해서 더 리서치를 했다.
  - 서버리스에 대한 개념이 더 확실하게 잡힌 느낌이다.
  - 그리고 Database를 서버리스로 바꾸는것도 가능한데, (AWS Aurora Serverless) 사실 이게 제일 처음 코스모 DB 인프라였다는걸 알게되고 적잖이 충격을 먹었다.
  - 결국 지금 중요한건 오토 스케일링 버그 원인 잡아내는거랑 DB 캐싱을 통해 성능을 끌어올리는것이다.
- 가스 데이터를 드디어 다 뽑아서 전달했다.
  - 3~4일간 고생했는데, 그래도 덕분에 이벤트 뽑는 연습은 충분히 된것 같다. 역시 해봐야 는다.
- foundry 가이드 블로깅을 게시했다.
- seaport order fulfilling 과정을 거의 다 파악했다.
  - 사실 별거 없었다. 어셈블리 코드가 많아서 그렇지...
  - order validation 하고 fulfilling 하고 execute 하는 일련의 과정을 여러 단계로 나누어서 적절한 컨트랙트에게 위임하는 방식이다.
  - 특히 토큰의 전송은 conduit 이라는 컨트랙트에 별도로 위임하게 된다. => 근데 이렇게 하는게 무슨 장점이 있는지는 모르겠음
- seaport를 참고해서 order struct를 좀 짜봤다. 내일은 전체 아키텍쳐를 한번 그려보자.

# 8월 24일 목요일

- 피곤해서 뻗었다. 컨디션이 좀 안좋았다.
- 필요한 api 작업좀 치고 como 데이터 정합성 체크좀 했다. 그 외에 기억나는건 음...

# 8월 25일 금요일

- 온체인과 DB 데이터를 비교해서 Como 데이터 정합성이 깨진 원인을 찾았다.
- api 작업도 스펙이 살짝 변경되긴 했는데 무리 없이 쳤다. JSON 상하차..
- seaport 이어서 보고 있는데 진짜 어렵다. 어셈블리의 극한까지 사용한 느낌.. 일단 큼직 큼직한 그림 위주로 보자.
- 사이드 플젝도 조금 작업했는데, 결과적으로 이전 아키텍쳐와 크게 달라지진 않을것 같다. 내일은 컨트랙트는 다 쳐보자.

# 8월 26일 토요일

- 사이드플젝 컨트랙트 초기 작업을 마무리했다.
  - 원래 최대한 Seaport 컨트랙트 구조를 참고해서 작업하려고 했는데, 그렇게 하니까 오히려 더 복잡해지는 느낌이었다.
  - 그래서 일단 하나의 컨트랙트에 모든 로직을 다 때려박았다. 이후 조금 더 고도화를 하면서 리팩터링을 해보자.
- 사이드플젝 백엔드 작업을 시작했다.
  - cosmo-backend랑 동일한 스펙, 구조로 진행하려고 한다.
  - 기존 코드도 익숙해질겸 겸사겸사 좋을것 같다.
  - 덕분에 tsoa에 대해서 다시 공부했다. tsoa는 swagger를 자동으로 만들어주는 라이브러리다.
